        - function global_update_backup_swap!(s::Stack, p::Parameters, l::Lattice)
        -   # swap current stack and greens to backup stack and greens (more efficient than copying)
        3   s.gb_u_stack, s.u_stack = s.u_stack, s.gb_u_stack
        3   s.gb_d_stack, s.d_stack = s.d_stack, s.gb_d_stack
        3   s.gb_t_stack, s.t_stack = s.t_stack, s.gb_t_stack
        3   s.gb_greens, s.greens = s.greens, s.gb_greens # this is greens at time slice == p.slices
        3   s.gb_log_det, s.log_det = s.log_det, s.gb_log_det # this is logdet of greens at time slice == p.slices + 1
        - end
        - 
        - 
        - function global_update_perform_shift!(s::Stack, p::Parameters, l::Lattice)
        -   # glob_dist = Uniform{Float64}(p.box.a/2., p.box.b/2.)
        -   # global_op_shift = rand(glob_dist, 3)
        2   global_op_shift = rand(p.box_global, 3)
        2   for i in 1:l.sites
      128     for n in 1:p.slices
     6400       p.hsfield[:,i,n] += global_op_shift
        -     end
        -   end
        - end
        - 
        - 
        - function global_update(s::Stack, p::Parameters, l::Lattice)
        - 
        2   assert(s.current_slice == p.slices && s.direction == -1)
        - 
        2   S_old = p.boson_action
        2   if !isapprox(S_old,calculate_boson_action(p, l)) warn("Incorrect boson action found during attempt to do global update.") end
        - 
        2   global_update_backup_swap!(s,p,l) # save current stack etc.
        2   s.gb_hsfield = copy(p.hsfield)
        - 
        2   global_update_perform_shift!(s,p,l)
        2   build_stack(s, p, l)
        2   propagate(s, p, l)
        -   # now we have s.greens = G_{p.slices} (up to one down-wrap) and s.log_det = logdet of G_{p.slices + 1} for new globally shifted conf
        - 
        2   p.boson_action = calculate_boson_action(p, l)
        - 
        -   # @printf("S_new: %.2e\n", p.boson_action)
        -   # @printf("S_old: %.2e\n", S_old)
        -   # @printf("S_new - S_old: %.2e\n", p.boson_action - S_old)
        2   p_boson = exp(-(p.boson_action - S_old)) # exp_delta_S_boson
        - 
        -   # calculate detratio = fermion accept. prob.
        2   p_fermion = exp(s.gb_log_det - s.log_det)
        - 
        2   p_acc = p_boson * real(p_fermion)
        - 
        -   # @printf("p_boson %.2e\n",abs.(p_boson))
        -   # @printf("p_fermion %.2e\n",abs.(p_fermion))
        -   # @printf("p_acc %.2e\n",abs.(p_acc))
        -   # println("")
        - 
        2   if p_acc > 1.0 || rand() < p_acc
        1     return 1
        -   else
        -     # undo global move
        1     p.boson_action = S_old
        1     p.hsfield = s.gb_hsfield
        1     global_update_backup_swap!(s,p,l)
        1     return 0
        -   end
        - 
        - end
