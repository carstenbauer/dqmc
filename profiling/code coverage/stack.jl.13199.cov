        - if !isdefined(:GreensType)
        -   global const GreensType = Complex128; # always complex for O(3)
        -   println("GreensType = ", GreensType)
        - end
        - 
        - mutable struct Stack
        -   u_stack::Array{GreensType, 3}
        -   d_stack::Array{Float64, 2}
        -   t_stack::Array{GreensType, 3}
        - 
        -   Ul::Array{GreensType, 2}
        -   Ur::Array{GreensType, 2}
        -   Dl::Array{Float64, 1}
        -   Dr::Array{Float64, 1}
        -   Tl::Array{GreensType, 2}
        -   Tr::Array{GreensType, 2}
        - 
        -   greens::Array{GreensType, 2}
        -   greens_temp::Array{GreensType, 2}
        -   log_det::Float64 # contains logdet of greens_{p.slices+1} === greens_1
        -                             # after we calculated a fresh greens in propagate()
        - 
        -   U::Array{GreensType, 2}
        -   D::Array{Float64, 1}
        -   T::Array{GreensType, 2}
        -   u::Array{GreensType, 2}
        -   d::Array{Float64, 1}
        -   t::Array{GreensType, 2}
        - 
        -   delta_i::Array{GreensType, 2}
        -   M::Array{GreensType, 2}
        - 
        -   eye_flv::Array{GreensType,2}
        -   eye_full::Array{GreensType,2}
        - 
        -   ranges::Array{UnitRange, 1}
        -   n_elements::Int
        -   current_slice::Int # running internally over 0:p.slices+1, where 0 and p.slices+1 are artifcial to prepare next sweep direction.
        -   direction::Int
        - 
        -   # -------- Global update backup
        -   gb_u_stack::Array{GreensType, 3}
        -   gb_d_stack::Array{Float64, 2}
        -   gb_t_stack::Array{GreensType, 3}
        - 
        -   gb_greens::Array{GreensType, 2}
        -   gb_log_det::Float64
        - 
        -   gb_hsfield::Array{Float64, 3}
        -   # --------
        - 
        3   Stack() = new()
        - end
        - 
        - 
        - function initialize_stack(s::Stack, p::Parameters, l::Lattice)
        2   s.n_elements = convert(Int, p.slices / p.safe_mult) + 1
        - 
        2   s.u_stack = zeros(Complex{Float64}, p.flv*l.sites, p.flv*l.sites, s.n_elements)
        2   s.d_stack = zeros(Float64, p.flv*l.sites, s.n_elements)
        2   s.t_stack = zeros(Complex{Float64}, p.flv*l.sites, p.flv*l.sites, s.n_elements)
        - 
        2   s.greens = zeros(Complex{Float64}, p.flv*l.sites, p.flv*l.sites)
        2   s.greens_temp = zeros(Complex{Float64}, p.flv*l.sites, p.flv*l.sites)
        - 
        2   s.Ul = eye(Complex{Float64}, p.flv*l.sites, p.flv*l.sites)
        2   s.Ur = eye(Complex{Float64}, p.flv*l.sites, p.flv*l.sites)
        2   s.Tl = eye(Complex{Float64}, p.flv*l.sites, p.flv*l.sites)
        2   s.Tr = eye(Complex{Float64}, p.flv*l.sites, p.flv*l.sites)
        2   s.Dl = ones(Float64, p.flv*l.sites)
        2   s.Dr = ones(Float64, p.flv*l.sites)
        - 
        2   s.U = zeros(Complex{Float64}, p.flv*l.sites, p.flv*l.sites)
        2   s.D = zeros(Float64, p.flv*l.sites)
        2   s.T = zeros(Complex{Float64}, p.flv*l.sites, p.flv*l.sites)
        2   s.u = zeros(Complex{Float64}, p.flv*l.sites, p.flv*l.sites)
        2   s.d = zeros(Float64, p.flv*l.sites)
        2   s.t = zeros(Complex{Float64}, p.flv*l.sites, p.flv*l.sites)
        - 
        2   s.delta_i = zeros(Complex{Float64}, p.flv, p.flv)
        2   s.M = zeros(Complex{Float64}, p.flv, p.flv)
        - 
        2   eye_flv = eye(p.flv,p.flv)
        2   eye_full = eye(p.flv*l.sites,p.flv*l.sites)
        - 
        -   # Global update backup
        2   s.gb_u_stack = zero(s.u_stack)
        2   s.gb_d_stack = zero(s.d_stack)
        2   s.gb_t_stack = zero(s.t_stack)
        2   s.gb_greens = zero(s.greens)
        2   s.gb_log_det = 0. 
        2   s.gb_hsfield = zero(p.hsfield)
        - 
        2   s.ranges = UnitRange[]
        - 
        2   for i in 1:s.n_elements - 1
        6     push!(s.ranges, 1 + (i - 1) * p.safe_mult:i * p.safe_mult)
        -   end
        - 
        - end
        - 
        - 
        - function build_stack(s::Stack, p::Parameters, l::Lattice)
        4   s.u_stack[:, :, 1] = eye(Complex{Float64}, p.flv*l.sites, p.flv*l.sites)
        4   s.d_stack[:, 1] = ones(p.flv*l.sites)
        4   s.t_stack[:, :, 1] = eye(Complex{Float64}, p.flv*l.sites, p.flv*l.sites)
        - 
        4   @inbounds for i in 1:length(s.ranges)
       16     add_slice_sequence_left(s, p, l, i)
        -   end
        - 
        4   s.current_slice = p.slices + 1
        4   s.direction = -1
        - 
        4   nothing
        - end
        - 
        - 
        - """
        - Updates stack[idx+1] based on stack[idx]
        - """
        - function add_slice_sequence_left(s::Stack, p::Parameters, l::Lattice, idx::Int)
       68   curr_U = copy(s.u_stack[:, :, idx])
        -   # println("Adding slice seq left $idx = ", s.ranges[idx])
       68   for slice in s.ranges[idx]
      680     if p.chkr
      680       multiply_slice_matrix_left!(p, l, slice, curr_U)
        -     else
        0       curr_U = slice_matrix_no_chkr(p, l, slice) * curr_U
        -     end
        -   end
        - 
       68   curr_U =  curr_U * spdiagm(s.d_stack[:, idx])
       68   s.u_stack[:, :, idx + 1], s.d_stack[:, idx + 1], T = decompose_udt(curr_U)
       68   s.t_stack[:, :, idx + 1] =  T * s.t_stack[:, :, idx]
        - end
        - 
        - 
        - """
        - Updates stack[idx] based on stack[idx+1]
        - """
        - function add_slice_sequence_right(s::Stack, p::Parameters, l::Lattice, idx::Int)
       52   curr_U = copy(s.u_stack[:, :, idx + 1])
        - 
       52   for slice in reverse(s.ranges[idx])
      520     if p.chkr
      520       curr_U = ctranspose(slice_matrix(p, l, slice)) * curr_U
        -     else
        0       curr_U = ctranspose(slice_matrix_no_chkr(p, l, slice)) * curr_U
        -     end
        -   end
       52   curr_U =  curr_U * spdiagm(s.d_stack[:, idx + 1])
       52   s.u_stack[:, :, idx], s.d_stack[:, idx], T = decompose_udt(curr_U)
       52   s.t_stack[:, :, idx] = T * s.t_stack[:, :, idx + 1]
        - end
        - 
        - 
        - # Beff(slice) = exp(−1/2∆τT)exp(−1/2∆τT)exp(−∆τV(slice))
        - function slice_matrix_no_chkr(p::Parameters, l::Lattice, slice::Int, power::Float64=1.)
        0   if power > 0
        0     return l.hopping_matrix_exp * l.hopping_matrix_exp * interaction_matrix_exp(p, l, slice, power)
        -   else
        0     return interaction_matrix_exp(p, l, slice, power) * l.hopping_matrix_exp_inv * l.hopping_matrix_exp_inv
        -   end
        - end
        - 
        - 
        - function wrap_greens_chkr!(p::Parameters, l::Lattice, gf::Array{GreensType,2}, curr_slice::Int,direction::Int)
     1032   if direction == -1
      524     multiply_slice_matrix_inv_left!(p, l, curr_slice - 1, gf)
      524     multiply_slice_matrix_right!(p, l, curr_slice - 1, gf)
        -   else
      508     multiply_slice_matrix_left!(p, l, curr_slice, gf)
      508     multiply_slice_matrix_inv_right!(p, l, curr_slice, gf)
        -   end
        - end
        - 
        - function wrap_greens_chkr(p::Parameters, l::Lattice, gf::Array{GreensType,2},slice::Int,direction::Int)
        -   temp = copy(gf)
        -   wrap_greens_chkr!(p, l, temp, slice, direction)
        -   return temp
        - end
        - 
        - 
        - function wrap_greens_no_chkr!(p::Parameters, l::Lattice, gf::Array{GreensType,2}, curr_slice::Int,direction::Int)
        0   if direction == -1
        0     gf[:] = slice_matrix_no_chkr(p, l, curr_slice - 1, -1.) * gf
        0     gf[:] = gf * slice_matrix_no_chkr(p, l, curr_slice - 1, 1.)
        -   else
        0     gf[:] = slice_matrix_no_chkr(p, l, curr_slice, 1.) * gf
        0     gf[:] = gf * slice_matrix_no_chkr(p, l, curr_slice, -1.)
        -   end
        - end
        - 
        - function wrap_greens_no_chkr(p::Parameters, l::Lattice, gf::Array{GreensType,2},slice::Int,direction::Int)
        -   temp = copy(gf)
        -   wrap_greens_no_chkr!(p, l, temp, slice, direction)
        -   return temp
        - end
        - 
        - 
        - """
        - Calculates G(slice) using s.Ur,s.Dr,s.Tr=B(slice)' ... B(M)' and s.Ul,s.Dl,s.Tl=B(slice-1) ... B(1)
        - """
        - function calculate_greens(s::Stack, p::Parameters, l::Lattice)
        - 
      108   tmp = s.Tl * ctranspose(s.Tr)
      108   s.U, s.D, s.T = decompose_udt(spdiagm(s.Dl) * tmp * spdiagm(s.Dr))
      108   s.U = s.Ul * s.U
      108   s.T *= ctranspose(s.Ur)
        - 
      108   s.u, s.d, s.t = decompose_udt(/(ctranspose(s.U), s.T) + spdiagm(s.D))
        - 
      108   s.T = inv(s.t * s.T)
      108   s.U *= s.u
      108   s.U = ctranspose(s.U)
      108   s.d = 1./s.d
        - 
      108   s.greens = s.T * spdiagm(s.d) * s.U
        - end
        - 
        - """
        - Only reasonable immediately after calculate_greens()!
        - """
        - function calculate_logdet(s::Stack, p::Parameters, l::Lattice)
       28   s.log_det = real(logdet(s.U) + sum(log.(s.d)) + logdet(s.T))
        - end
        - 
        - 
        - ################################################################################
        - # Propagation
        - ################################################################################
        - function propagate(s::Stack, p::Parameters, l::Lattice)
     1068   if s.direction == 1
      532     if mod(s.current_slice, p.safe_mult) == 0
       64       s.current_slice +=1 # slice we are going to
       64       if s.current_slice == 1
       12         s.Ur[:, :], s.Dr[:], s.Tr[:, :] = s.u_stack[:, :, 1], s.d_stack[:, 1], s.t_stack[:, :, 1]
       12         s.u_stack[:, :, 1] = eye(Complex{Float64}, p.flv*l.sites, p.flv*l.sites)
       12         s.d_stack[:, 1] = ones(p.flv*l.sites)
       12         s.t_stack[:, :, 1] = eye(Complex{Float64}, p.flv*l.sites, p.flv*l.sites)
       12         s.Ul[:,:], s.Dl[:], s.Tl[:,:] = s.u_stack[:, :, 1], s.d_stack[:, 1], s.t_stack[:, :, 1]
        - 
       12         calculate_greens(s, p, l) # greens_1 ( === greens_{m+1} )
       12         calculate_logdet(s, p, l)
        - 
       52       elseif 1 < s.current_slice <= p.slices
       40         idx = Int((s.current_slice - 1)/p.safe_mult)
        - 
       40         s.Ur[:, :], s.Dr[:], s.Tr[:, :] = s.u_stack[:, :, idx+1], s.d_stack[:, idx+1], s.t_stack[:, :, idx+1]
       40         add_slice_sequence_left(s, p, l, idx)
       40         s.Ul[:,:], s.Dl[:], s.Tl[:,:] = s.u_stack[:, :, idx+1], s.d_stack[:, idx+1], s.t_stack[:, :, idx+1]
        - 
       40         s.greens_temp = copy(s.greens)
       40         if p.chkr
       40           wrap_greens_chkr!(p, l, s.greens_temp, s.current_slice - 1, 1)
        -         else
        0           wrap_greens_no_chkr!(p, l, s.greens_temp, s.current_slice - 1, 1)
        -         end
        - 
       40         calculate_greens(s, p, l) # greens_{slice we are propagating to}
        - 
       40         diff = maximum(absdiff(s.greens_temp, s.greens))
       40         if diff > 1e-7
        0           @printf("->%d \t+1 Propagation instability\t %.4f\n", s.current_slice, diff)
        -         end
        - 
        -         # errs = (effreldiff(s.greens_temp, s.greens) .> 1e-2) .& (absdiff(s.greens_temp, s.greens) .> 1e-04)
        -         # if sum(errs)>0
        -         #   maxrelerr = maximum(effreldiff(s.greens_temp, s.greens)[errs])*100
        -         #   maxabsolute = maximum(absdiff(s.greens_temp, s.greens)[errs])
        -         #   @printf("->%d \t+1 Propagation stability\t max absolute: %.4f \t max relative: %.1f%%\n", s.current_slice, maxabsolute, maxrelerr)
        -         # end
        - 
        -       else # we are going to p.slices+1
       12         idx = s.n_elements - 1
       12         add_slice_sequence_left(s, p, l, idx)
       12         s.direction = -1
       12         s.current_slice = p.slices+1 # redundant
       12         propagate(s, p, l)
        -       end
        - 
        -     else
        -       # Wrapping
      468       if p.chkr
      468         wrap_greens_chkr!(p, l, s.greens, s.current_slice, 1)
        -       else
        0         wrap_greens_no_chkr!(p, l, s.greens, s.current_slice, 1)
        -       end
      468       s.current_slice += 1
        -     end
        - 
        -   else # s.direction == -1
      536     if mod(s.current_slice-1, p.safe_mult) == 0
       68       s.current_slice -= 1 # slice we are going to
       68       if s.current_slice == p.slices
       16         s.Ul[:, :], s.Dl[:], s.Tl[:, :] = s.u_stack[:, :, end], s.d_stack[:, end], s.t_stack[:, :, end]
       16         s.u_stack[:, :, end] = eye(Complex{Float64}, p.flv*l.sites, p.flv*l.sites)
       16         s.d_stack[:, end] = ones(p.flv*l.sites)
       16         s.t_stack[:, :, end] = eye(Complex{Float64}, p.flv*l.sites, p.flv*l.sites)
       16         s.Ur[:,:], s.Dr[:], s.Tr[:,:] = s.u_stack[:, :, end], s.d_stack[:, end], s.t_stack[:, :, end]
        - 
       16         calculate_greens(s, p, l) # greens_{p.slices+1} === greens_1
       16         calculate_logdet(s, p, l) # calculate logdet for potential global update
        - 
        -         # wrap to greens_{p.slices}
       16         if p.chkr
       16           wrap_greens_chkr!(p, l, s.greens, s.current_slice + 1, -1)
        -         else
        0           wrap_greens_no_chkr!(p, l, s.greens, s.current_slice + 1, -1)
        -         end
        - 
       52       elseif 0 < s.current_slice < p.slices
       40         idx = Int(s.current_slice / p.safe_mult) + 1
       40         s.Ul[:, :], s.Dl[:], s.Tl[:, :] = s.u_stack[:, :, idx], s.d_stack[:, idx], s.t_stack[:, :, idx]
       40         add_slice_sequence_right(s, p, l, idx)
       40         s.Ur[:,:], s.Dr[:], s.Tr[:,:] = s.u_stack[:, :, idx], s.d_stack[:, idx], s.t_stack[:, :, idx]
        - 
       40         s.greens_temp = copy(s.greens)
        - 
       40         calculate_greens(s, p , l)
        - 
       40         diff = maximum(absdiff(s.greens_temp, s.greens))
       40         if diff > 1e-7
        0           @printf("->%d \t-1 Propagation instability\t %.4f\n", s.current_slice, diff)
        -         end
        - 
        -         # errs = (effreldiff(s.greens_temp, s.greens) .> 1e-2) .& (absdiff(s.greens_temp, s.greens) .> 1e-04)
        -         # if sum(errs)>0
        -         #   maxrelerr = maximum(effreldiff(s.greens_temp, s.greens)[errs])*100
        -         #   maxabsolute = maximum(absdiff(s.greens_temp, s.greens)[errs])
        -         #   @printf("->%d \t-1 Propagation stability\t max absolute: %.4f \t max relative: %.1f%%\n", s.current_slice, maxabsolute, maxrelerr)
        -         # end
        - 
       40         if p.chkr
       40           wrap_greens_chkr!(p, l, s.greens, s.current_slice + 1, -1)
        -         else
        0           wrap_greens_no_chkr!(p, l, s.greens, s.current_slice + 1, -1)
        -         end
        - 
        -       else # we are going to 0
       12         idx = 1
       12         add_slice_sequence_right(s, p, l, idx)
       12         s.direction = 1
       12         s.current_slice = 0 # redundant
       12         propagate(s,p,l)
        -       end
        - 
        -     else
        -       # Wrapping
      468       if p.chkr
      468         wrap_greens_chkr!(p, l, s.greens, s.current_slice, -1)
        -       else
        0         wrap_greens_no_chkr!(p, l, s.greens, s.current_slice, -1)
        -       end
      468       s.current_slice -= 1
        -     end
        -   end
        -   # compare(s.greens,calculate_greens_udv(p,l,s.current_slice))
        -   # compare(s.greens,calculate_greens_udv_chkr(p,l,s.current_slice))
     1068   nothing
        - end
