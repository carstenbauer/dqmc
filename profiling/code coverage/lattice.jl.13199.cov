        - using LightXML
        - using Helpers
        - 
        - if !isdefined(:HoppingType)
        -   global const HoppingType = Float64;
        - end
        - 
        - # define lattice type
        - mutable struct Lattice
        -   dim::Int
        -   sites::Int
        -   L::Int
        -   n_neighbors::Int
        -   n_bonds::Int
        -   t::Array{Float64, 2} # colidx = flavor, rowidx = hor,ver
        -   time_neighbors::Array{Int, 2} # colidx = slice, rowidx = up, down
        -   neighbors::Array{Int, 2} # colidx = site
        -                            # first = up, second = right, third and fourth not ordered
        -   bonds::Array{Int, 2}
        -   bond_vecs::Array{Float64, 2}
        -   site_bonds::Array{Int, 2}
        - 
        -   hopping_matrix_exp::Array{HoppingType, 2} # mu included
        -   hopping_matrix_exp_inv::Array{HoppingType, 2}
        - 
        -   chkr_hop_half::Array{SparseMatrixCSC{HoppingType, Int64}, 1}
        -   chkr_hop_half_inv::Array{SparseMatrixCSC{HoppingType, Int64}, 1}
        -   chkr_hop::Array{SparseMatrixCSC{HoppingType, Int64}, 1} # without prefactor 0.5 in matrix exponentials
        -   chkr_hop_inv::Array{SparseMatrixCSC{HoppingType, Int64}, 1}
        -   chkr_mu_half::SparseMatrixCSC{HoppingType, Int64}
        -   chkr_mu_half_inv::SparseMatrixCSC{HoppingType, Int64}
        -   chkr_mu::SparseMatrixCSC{HoppingType, Int64}
        -   chkr_mu_inv::SparseMatrixCSC{HoppingType, Int64}
        - 
        -   # peter remnants
        -   checkerboard::Array{Int, 2}
        -   groups::Array{UnitRange, 1}
        - 
        1   Lattice() = new()
        - end
        - 
        - # TODO: checkerboard content in this function
        - # TODO: too general for square lattice! leave it that way?
        - function init_lattice_from_filename(filename::String, l::Lattice)
        3   xdoc = parse_file(filename)
        3   xroot = LightXML.root(xdoc)
        3   l.sites = 1
        - 
        3   for a in attributes(xroot)
        9       if LightXML.name(a) == "vertices"
        3         l.sites = parse(Int, value(a))
        6       elseif LightXML.name(a) == "dimension"
        3         l.dim = parse(Int, value(a))
        -       end
        -     end
        - 
        3   edges = get_elements_by_tagname(xroot, "EDGE")
        3   l.n_bonds = length(edges)
        - 
        -   # checkerboard
        -   # l.chkr_hop = SparseMatrixCSC[]
        -   # l.chkr_hop_inv = SparseMatrixCSC[]
        3   l.groups = UnitRange[]
        3   l.n_neighbors = 0
        3   edges_used = zeros(Int64, length(edges))
        3   l.checkerboard = zeros(3, length(edges))
        3   group_start = 1
        3   group_end = 1
        - 
        3   while minimum(edges_used) == 0
       12     sites_used = zeros(Int64, l.sites)
        - 
       12     for e in edges
     1152       src = 0
     1152       trg = 0
     1152       bd_type = 0
     1152       bd_id = 0
        - 
     1152       for a = attributes(e)
     5760         if LightXML.name(a) == "source"
     1152           src = parse(Int, value(a))
     4608         elseif LightXML.name(a) == "target"
     1152           trg = parse(Int, value(a))
     3456         elseif LightXML.name(a) == "type"
     1152           bd_type = parse(Int, value(a)) + 1
     2304         elseif LightXML.name(a) == "id"
     1152           bd_id = parse(Int, value(a))
        -         end end
        - 
     1584       if edges_used[bd_id] == 1 continue end
     1132       if sites_used[src] == 1 continue end
      328       if sites_used[trg] == 1 continue end
        - 
      288       if src == 1 || trg == 1
        -         # println("Bond ", src, " - ", trg)
       12         l.n_neighbors += 1 end
        - 
      288       edges_used[bd_id] = 1
      288       sites_used[src] = 1
      288       sites_used[trg] = 1
        - 
      288       l.checkerboard[:, group_end] = [src, trg, bd_type]
      288       group_end += 1
        -     end
       12     push!(l.groups, group_start:group_end-1)
       12     group_start = group_end
        -   end
        - 
        -   # bonds & bond vectors
        3   println("\nLoading lattice with ", l.sites , " sites")
        3   l.bonds = zeros(l.n_bonds, 2)
        3   l.bond_vecs = zeros(l.n_bonds, l.dim)
        3   l.site_bonds = zeros(l.sites, l.n_neighbors)
        3   for (e_idx, e) in enumerate(edges)
      288     src = 0
      288     trg = 0
      288     vec = Vector{Float64}(l.dim)
      288     for a = attributes(e)
     1440       if LightXML.name(a) == "source"
      288         src = parse(Int, value(a))
     1152       elseif LightXML.name(a) == "target"
      288         trg = parse(Int, value(a))
      864       elseif LightXML.name(a) == "vector"
      288         vec = [parse(Float64, f) for f in split(value(a)," ")]
        -       end
        -     end
        - 
      288     l.bonds[e_idx, 1] = src
      288     l.bonds[e_idx, 2] = trg
      288     l.bond_vecs[e_idx, :] = vec
        - 
      288     idx = findfirst(l.site_bonds[src, :], 0)
      288     l.site_bonds[src, idx] = e_idx
      288     idx = findfirst(l.site_bonds[trg, :], 0)
      288     l.site_bonds[trg, idx] = e_idx
        -   end
        - 
        3   for i in 1:l.sites
      144     if findfirst(l.site_bonds[i, :], 0) != 0
        0       println(i)
        0       println(l.site_bonds[i, :])
        0       println(findfirst(l.site_bonds[i, :]))
        0       error("l.site_bonds is not correctly setup")
        -     end
        -   end
        - end
        - 
        - function init_hopping_matrix_exp(p::Parameters,l::Lattice)::Void
        3   Tx = diagm(fill(-p.mu,l.sites))
        3   Ty = diagm(fill(-p.mu,l.sites))
        3   for b in 1:l.n_bonds
      288     src = l.bonds[b,1]
      288     trg = l.bonds[b,2]
      288     if l.bond_vecs[b,1] == 1
      144       Tx[trg,src] = Tx[src,trg] += -l.t[1,1]
      144       Ty[trg,src] = Ty[src,trg] += -l.t[1,2]
        -     else
      144       Tx[trg,src] = Tx[src,trg] += -l.t[2,1]
      144       Ty[trg,src] = Ty[src,trg] += -l.t[2,2]
        -     end
        -   end
        - 
        3   eTx_minus = expm(-0.5 * p.delta_tau * Tx)
        3   eTy_minus = expm(-0.5 * p.delta_tau * Ty)
        3   eTx_plus = expm(0.5 * p.delta_tau * Tx)
        3   eTy_plus = expm(0.5 * p.delta_tau * Ty)
        3   l.hopping_matrix_exp = cat([1,2],eTx_minus,eTy_minus,eTx_minus,eTy_minus)
        3   l.hopping_matrix_exp_inv = cat([1,2],eTx_plus,eTy_plus,eTx_plus,eTy_plus)
        3   return nothing
        - end
        - 
        - 
        - function peirls(i::Int , j::Int, B::Float64, sql::Matrix{Int}, pbc::Bool)::Complex128
        -     # peirls_phase_factors e^{im*Aij}
        -     # argument pbc: is this hopping via PBC (true) or within the finite lattice (false)
        0     i2, i1 = ind2sub(sql, i)
        0     j2, j1 = ind2sub(sql, j)
        0     L = size(sql, 1)
        - 
        0     if !pbc
        0       if i1 in 1:L-1 && j1 == i1+1
        0           return exp(im*(- 2*pi * B * (i2 - 1)))
        -           
        0       elseif i1 in 2:L && j1 == i1-1
        0           return exp(im*(2*pi * B * (i2 - 1)))
        -           
        -       else
        0           return exp(im*0.)
        -       end
        -       
        -     else
        0       if i1 == L && j1 == 1
        0           return exp(im*(- 2*pi * B * (i2 - 1)))
        -           
        0       elseif i1 == 1 && j1 == L
        0           return exp(im*(2*pi * B * (i2 - 1)))
        -           
        0       elseif i2 == L && j2 == 1
        0           return exp(im*(2*pi * B * L * (i1 - 1)))
        -           
        0       elseif i2 == 1 && j2 == L
        0           return exp(im*(- 2*pi * B * L * (i1 - 1)))
        -           
        -       else
        0           return exp(im*0.)
        -       end
        -     end
        - end
        - 
        - function init_hopping_matrix_exp_Bfield(p::Parameters,l::Lattice)::Void
        0   B = zeros(2,2) # colidx = flavor, rowidx = spin up,down
        0   if p.Bfield
        0     B[1,1] = B[2,2] = 1./l.sites
        0     B[1,2] = B[2,1] = - 1./l.sites
        -   end
        - 
        0   T = Matrix{Matrix{HoppingType}}(2,2) # colidx = flavor, rowidx = spin up,down
        0   for i in 1:4
        0     T[i] = convert(Matrix{HoppingType}, diagm(fill(-p.mu,l.sites)))
        -   end
        - 
        -   # for linidx to cartesianidx   
        0   sql = reshape(collect(1:l.sites), (l.L,l.L))
        - 
        0   for b in 1:l.n_bonds
        0     src = l.bonds[b,1]
        0     trg = l.bonds[b,2]
        0     pbc = trg < src
        0     if l.bond_vecs[b,1] == 1 #hopping direction
        0       for f in 1:2 #flv
        0         for s in 1:2 #spin
        0           T[s,f][trg,src] += - peirls(trg, src, B[s,f], sql, pbc) * l.t[1,f]
        0           T[s,f][src,trg] += - peirls(src, trg, B[s,f], sql, pbc) * l.t[1,f]
        -         end
        -       end
        -     else
        0       for f in 1:2
        0         for s in 1:2
        0           T[s,f][trg,src] += - peirls(trg, src, B[s,f], sql, pbc) * l.t[2,f]
        0           T[s,f][src,trg] += - peirls(src, trg, B[s,f], sql, pbc) * l.t[2,f]
        -         end
        -       end
        -     end
        -   end
        - 
        0   eT_minus = map(Ti -> expm(-0.5 * p.delta_tau * Ti), T)
        0   eT_plus = map(Ti -> expm(0.5 * p.delta_tau * Ti), T)
        - 
        0   l.hopping_matrix_exp = cat([1,2], eT_minus[1,1], eT_minus[2,2], eT_minus[2,1], eT_minus[1,2])
        0   l.hopping_matrix_exp_inv = cat([1,2], eT_plus[1,1], eT_plus[2,2], eT_plus[2,1], eT_plus[1,2])
        - 
        0   return nothing
        - end
        - 
        - 
        - function init_neighbors_table(p::Parameters,l::Lattice)
        -   # OPT: neighbor table: sort down and left neighbors
        3   l.neighbors = zeros(Int64, 4, l.sites) # unsorted order of neighbors
        3   for i in 1:l.sites
     1296     l.neighbors[:,i] = filter(x->x!=i,l.bonds[l.site_bonds[i,:],:])
        -   end
        3   swap_rows!(l.neighbors,3,1)
        3   swap_rows!(l.neighbors,4,2)
        - end
        - 
        - 
        - """
        - Periodic boundary conditions in imaginary time
        - """
        - function init_time_neighbors_table(p::Parameters,l::Lattice)
        3   l.time_neighbors = zeros(Int64, 2, p.slices)
        3   for s in 1:p.slices
      110     l.time_neighbors[1,s] = s==p.slices?1:s+1
      110     l.time_neighbors[2,s] = s==1?p.slices:s-1
        -   end
        - end
        - 
