        - using ProfileView
        - 
        - # dqmc.jl called with arguments: sdwO3_L_4_B_2_dt_0.1_1 ${SLURM_ARRAY_TASK_ID}
        - start_time = now()
        - println("Started: ", Dates.format(start_time, "d.u yyyy HH:MM"))
        - 
        - using Helpers
        - using Git
        - include("../linalg.jl")
        - include("../parameters.jl")
        - include("../xml_parameters.jl")
        - 
        - # @inbounds begin
        - ARGS = ["sdwO3_L_8_B_5_dt_0.1_1", 1]
        - prefix = convert(String, ARGS[1])
        - idx = 1
        - try
        -   idx = parse(Int, ARGS[2]) # SLURM_ARRAY_TASK_ID
        - end
        - output_file = prefix * ".task" * string(idx) * ".out.h5"
        - 
        - # hdf5 write test
        - f = HDF5.h5open(output_file, "w")
        - f["params/TEST"] = 42
        - close(f)
        - 
        - # load parameters xml
        - params = Dict{Any, Any}()
        - try
        -   println("Prefix is ", prefix, " and idx is ", idx)
        -   params = xml2parameters(prefix * ".task" * string(idx) * ".in.xml")
        - 
        -   # Check and store code version (git commit)
        -   if haskey(params,"GIT_COMMIT_DQMC") && Git.head(dir=dirname(@__FILE__)) != params["GIT_COMMIT_DQMC"]
        -     warn("Git commit in input xml file does not match current commit of code.")
        -   end
        -   params["GIT_COMMIT_DQMC"] = Git.head(dir=dirname(@__FILE__))
        - 
        -   parameters2hdf5(params, output_file)
        - catch e
        -   println(e)
        - end
        - 
        - 
        - ### PARAMETERS
        - p = Parameters()
        - p.output_file = output_file
        - p.thermalization = parse(Int, params["THERMALIZATION"])
        - p.measurements = parse(Int, params["MEASUREMENTS"])
        - p.slices = parse(Int, params["SLICES"])
        - p.delta_tau = parse(Float64, params["DELTA_TAU"])
        - p.safe_mult = parse(Int, params["SAFE_MULT"])
        - p.lattice_file = params["LATTICE_FILE"]
        - srand(parse(Int, params["SEED"]))
        - p.mu = parse(Float64, params["MU"])
        - p.lambda = parse(Float64, params["LAMBDA"])
        - p.r = parse(Float64, params["R"])
        - p.c = parse(Float64, params["C"])
        - p.u = parse(Float64, params["U"])
        - p.global_updates = haskey(params,"GLOBAL_UPDATES")?parse(Bool, lowercase(params["GLOBAL_UPDATES"])):true;
        - p.chkr = haskey(params,"CHECKERBOARD")?parse(Bool, lowercase(params["CHECKERBOARD"])):true;
        - p.Bfield = haskey(params,"B_FIELD")?parse(Bool, lowercase(params["B_FIELD"])):false;
        - p.beta = p.slices * p.delta_tau
        - p.flv = 4
        - if haskey(params,"BOX_HALF_LENGTH")
        -   p.box = Uniform(-parse(Float64, params["BOX_HALF_LENGTH"]),parse(Float64, params["BOX_HALF_LENGTH"]))
        - else
        -   p.box = Uniform(-0.2,0.2)
        - end
        - if haskey(params,"BOX_GLOBAL_HALF_LENGTH")
        -   p.box_global = Uniform(-parse(Float64, params["BOX_GLOBAL_HALF_LENGTH"]),parse(Float64, params["BOX_GLOBAL_HALF_LENGTH"]))
        - else
        -   p.box_global = Uniform(-0.1,0.1)
        - end
        - if haskey(params,"GLOBAL_RATE")
        -   p.global_rate = parse(Int64, params["GLOBAL_RATE"])
        - else
        -   p.global_rate = 5
        - end
        - if haskey(params,"WRITE_EVERY_NTH")
        -   p.write_every_nth = parse(Int64, params["WRITE_EVERY_NTH"])
        - else
        -   p.write_every_nth = 1
        - end
        - 
        - ## Set datatypes
        - global const HoppingType = p.Bfield ? Complex128 : Float64;
        - global const GreensType = Complex128;
        - println("HoppingType = ", HoppingType)
        - println("GreensType = ", GreensType)
        - 
        - 
        - include("../lattice.jl")
        - include("../checkerboard.jl")
        - include("../interactions.jl")
        - include("../action.jl")
        - include("../stack.jl")
        - include("../local_updates.jl")
        - include("../global_updates.jl")
        - include("../observable.jl")
        - include("../boson_measurements.jl")
        - include("../fermion_measurements.jl")
        - # include("tests/tests_gf_functions.jl")
        - 
        - mutable struct Analysis
        -     acc_rate::Float64
        -     acc_rate_global::Float64
        -     prop_global::Int
        -     acc_global::Int
        - 
        3     Analysis() = new()
        - end
        - 
        - function init_compilation(p::Parameters, l::Lattice)
        1   p.slices = 10
        1   p.thermalization = 2
        1   p.measurements = 2
        - 
        1   l.L = 4
        1   @static if is_windows()
        -     lattice_file = "C:/Users/carsten/Desktop/sciebo/lattices/square_L_4_W_4.xml"
        -   end
        1   @static if is_linux()
        1     lattice_file = "/home/bauer/lattices/square_L_4_W_4.xml"
        -   end
        - 
        1   init_lattice_from_filename(lattice_file, l)
        1   init_neighbors_table(p,l)
        1   init_time_neighbors_table(p,l)
        1   println("Initializing hopping exponentials")
        1   if p.Bfield
        0     init_hopping_matrix_exp_Bfield(p,l)
        -   else
        1     init_hopping_matrix_exp(p,l)
        -   end
        1   if p.chkr
        1     if p.Bfield
        0       init_checkerboard_matrices_Bfield(p,l)
        -     else
        1       init_checkerboard_matrices(p,l)
        -     end
        -   end
        - end
        - 
        - 
        - function init_profiling(p::Parameters, l::Lattice)
        1   p.slices = 50
        1   p.thermalization = 10
        1   p.measurements = 10
        - 
        1   l.L = 8
        1   @static if is_windows()
        -     lattice_file = "C:/Users/carsten/Desktop/sciebo/lattices/square_L_8_W_8.xml"
        -   end
        1   @static if is_linux()
        1     lattice_file = "/home/bauer/lattices/square_L_8_W_8.xml"
        -   end
        - 
        1   init_lattice_from_filename(lattice_file, l)
        1   init_neighbors_table(p,l)
        1   init_time_neighbors_table(p,l)
        1   println("Initializing hopping exponentials")
        1   if p.Bfield
        0     init_hopping_matrix_exp_Bfield(p,l)
        -   else
        1     init_hopping_matrix_exp(p,l)
        -   end
        1   if p.chkr
        1     if p.Bfield
        0       init_checkerboard_matrices_Bfield(p,l)
        -     else
        1       init_checkerboard_matrices(p,l)
        -     end
        -   end
        - end
        - 
        - 
        - function main(p::Parameters)
        -     
        -     ### LATTICE
        1     l = Lattice()
        1     Lpos = maximum(search(p.lattice_file,"L_"))+1
        1     l.L = parse(Int, p.lattice_file[Lpos:Lpos+minimum(search(p.lattice_file[Lpos:end],"_"))-2])
        1     l.t = reshape([parse(Float64, f) for f in split(params["HOPPINGS"], ',')],(2,2))
        1     init_lattice_from_filename(params["LATTICE_FILE"], l)
        1     println("Initializing neighbor-tables")
        1     init_neighbors_table(p,l)
        1     init_time_neighbors_table(p,l)
        1     println("Initializing hopping exponentials")
        1     if p.Bfield
        0       init_hopping_matrix_exp_Bfield(p,l)
        -     else
        1       init_hopping_matrix_exp(p,l)
        -     end
        1     if p.chkr
        1       if p.Bfield
        0         init_checkerboard_matrices_Bfield(p,l)
        -       else
        1         init_checkerboard_matrices(p,l)
        -       end
        -     end
        - 
        1     s = Stack()
        1     a = Analysis()
        - 
        -     # $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ Run once, to force compilation.
        1     println("======================= First run:")
        1     srand(666)
        1     init_compilation(p,l)
        1     s = Stack()
        1     a = Analysis()
        1     @time MC_thermalize(s, p, l, a)
        - 
        -     # Run a second time, with profiling.
        1     println("\n\n======================= Second run:")
        1     srand(666)
        1     init_profiling(p,l)
        1     s = Stack()
        1     a = Analysis()
        1     Profile.init(n=10^7, delay=0.01) # delay=0.01
        1     Profile.clear()
        1     Profile.clear_malloc_data()
        1     @profile @time MC_thermalize(s, p, l, a)
        - 
        -     # Write profile results to profile.bin and profile.svg
        1     ProfileView.svgwrite("profile.svg")
        1     r = Profile.retrieve()
        1     f = open("profile.bin", "w")
        1     serialize(f, r)
        1     close(f)
        1     exit()
        -     # $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
        - 
        - 
        -     ### MONTE CARLO
        0     println("\n\nMC Thermalize - ", p.thermalization)
        0     MC_thermalize(s, p, l, a)
        - 
        0     println("\n\nMC Measure - ", p.measurements)
        0     MC_measure(s, p, l, a)
        - 
        0     nothing
        - end
        - 
        - 
        - function MC_thermalize(s::Stack, p::Parameters, l::Lattice, a::Analysis)
        - 
        -     # init hsfield
        2     println("\nInitializing HS field")
        2     p.hsfield = rand(3,l.sites,p.slices)
        2     println("Initializing boson action\n")
        2     p.boson_action = calculate_boson_action(p,l)
        - 
        -     # stack init and test
        2     initialize_stack(s, p, l)
        2     println("Building stack")
        2     build_stack(s, p, l)
        - 
        2     println("Initial propagate: ", s.current_slice, " ", s.direction)
        2     propagate(s, p, l)
        - 
        2     a.acc_rate = 0.0
        2     a.acc_rate_global = 0.0
        2     a.prop_global = 0
        2     a.acc_global = 0
        2     tic()
        2     for i in 1:p.thermalization
       12       println("step $i")
       12       for u in 1:2 * p.slices
     1040         MC_update(s, p, l, i, a)
        -       end
        - 
       12       if mod(i, 10) == 0
        1         a.acc_rate = a.acc_rate / (10 * 2 * p.slices)
        1         a.acc_rate_global = a.acc_rate_global / (10 / p.global_rate)
        1         println("\t", i)
        1         @printf("\t\tup-down sweep dur: %.2fs\n", toq()/10)
        1         @printf("\t\tacc rate (local) : %.1f%%\n", a.acc_rate*100)
        1         if p.global_updates
        1           @printf("\t\tacc rate (global): %.1f%%\n", a.acc_rate_global*100)
        1           @printf("\t\tacc rate (global, overall): %.1f%%\n", a.acc_global/a.prop_global*100)
        -         end
        - 
        -         # adaption (first half of thermalization)
        1         if i < p.thermalization / 2 + 1
        0           if a.acc_rate < 0.5
        0             @printf("\t\tshrinking box: %.2f\n", 0.9*p.box.b)
        0             p.box = Uniform(-0.9*p.box.b,0.9*p.box.b)
        -           else
        0             @printf("\t\tenlarging box: %.2f\n", 1.1*p.box.b)
        0             p.box = Uniform(-1.1*p.box.b,1.1*p.box.b)
        -           end
        - 
        0           if p.global_updates
        0           if a.acc_global/a.prop_global < 0.5
        0             @printf("\t\tshrinking box_global: %.2f\n", 0.9*p.box_global.b)
        0             p.box_global = Uniform(-0.9*p.box_global.b,0.9*p.box_global.b)
        -           else
        0             @printf("\t\tenlarging box_global: %.2f\n", 1.1*p.box_global.b)
        0             p.box_global = Uniform(-1.1*p.box_global.b,1.1*p.box_global.b)
        -           end
        -           end
        -         end
        1         a.acc_rate = 0.0
        1         a.acc_rate_global = 0.0
        1         flush(STDOUT)
        1         tic()
        -       end
        - 
        -     end
        2     toq();
        2     nothing
        - end
        - 
        - 
        - function MC_measure(s::Stack, p::Parameters, l::Lattice, a::Analysis)
        - 
        0     initialize_stack(s, p, l)
        0     println("Renewing stack")
        0     build_stack(s, p, l)
        0     println("Initial propagate: ", s.current_slice, " ", s.direction)
        0     propagate(s, p, l)
        - 
        0     cs = min(p.measurements, 100)
        - 
        0     configurations = Observable{Float64}("configurations", size(p.hsfield), cs)
        0     greens = Observable{Complex{Float64}}("greens", size(s.greens), cs)
        - 
        0     boson_action = Observable{Float64}("boson_action", cs)
        0     mean_abs_op = Observable{Float64}("mean_abs_op", cs)
        0     mean_op = Observable{Float64}("mean_op", (3), cs)
        - 
        - 
        0     acc_rate = 0.0
        0     acc_rate_global = 0.0
        0     tic()
        0     for i in 1:p.measurements
        0       for u in 1:2 * p.slices
        0         MC_update(s, p, l, i, a)
        - 
        0         if s.current_slice == p.slices && s.direction == 1 && (i-1)%p.write_every_nth == 0 # measure criterium
        -           # println("\t\tMeasuring")
        0           add_element(boson_action, p.boson_action)
        - 
        0           curr_mean_abs_op, curr_mean_op = measure_op(p.hsfield)
        0           add_element(mean_abs_op, curr_mean_abs_op)
        0           add_element(mean_op, curr_mean_op)
        - 
        0           add_element(configurations, p.hsfield)
        0           add_element(greens, s.greens)
        -           
        0           if p.chkr
        0             effective_greens2greens!(p, l, greens.timeseries[:,:,greens.count])
        -           else
        0             effective_greens2greens_no_chkr!(p, l, greens.timeseries[:,:,greens.count])
        -           end
        - 
        -           # compare(greens.timeseries[:,:,greens.count], measure_greens_and_logdet(p, l, p.safe_mult)[1])
        - 
        -           # add_element(greens, measure_greens_and_logdet(p, l, p.safe_mult)[1])
        - 
        0           if boson_action.count == cs
        0               println("Dumping...")
        0             @time begin
        0               confs2hdf5(p.output_file, configurations)
        0               obs2hdf5(p.output_file, greens)
        - 
        0               obs2hdf5(p.output_file, boson_action)
        0               obs2hdf5(p.output_file, mean_abs_op)
        0               obs2hdf5(p.output_file, mean_op)
        0               clear(boson_action)
        0               clear(mean_abs_op)
        0               clear(mean_op)
        - 
        0               clear(configurations)
        0               clear(greens)
        0               println("Dumping block of $cs datapoints was a success")
        0               flush(STDOUT)
        -             end
        -           end
        -         end
        -       end
        0       if mod(i, 100) == 0
        0         a.acc_rate = a.acc_rate / (10 * 2 * p.slices)
        0         a.acc_rate_global = a.acc_rate_global / (10 / p.global_rate)
        0         println("\t", i)
        0         @printf("\t\tup-down sweep dur: %.2fs\n", toq()/10)
        0         @printf("\t\tacc rate (local) : %.1f%%\n", a.acc_rate*100)
        0         if p.global_updates
        0           @printf("\t\tacc rate (global): %.1f%%\n", a.acc_rate_global*100)
        0           @printf("\t\tacc rate (global, overall): %.1f%%\n", a.acc_global/a.prop_global*100)
        -         end
        0         a.acc_rate = 0.0
        0         a.acc_rate_global = 0.0
        0         flush(STDOUT)
        0         tic()
        -       end
        -     end
        0     toq();
        0     nothing
        - end
        - 
        - 
        - function MC_update(s::Stack, p::Parameters, l::Lattice, i::Int, a::Analysis)
        - 
     1040     propagate(s, p, l)
        - 
     1040     if p.global_updates && (s.current_slice == p.slices && s.direction == -1 && mod(i, p.global_rate) == 0)
        -       # attempt global update after every fifth down-up sweep
        -       # println("Attempting global update...")
        2       a.prop_global += 1
        2       b = global_update(s, p, l)
        2       a.acc_rate_global += b
        2       a.acc_global += b
        -       # println("Accepted: ", b)
        -     end
        - 
        -     # println("Before local")
        -     # compare(s.greens, calculate_greens_udv_chkr(p,l,s.current_slice))
     1040     a.acc_rate += local_updates(s, p, l)
        -     # println("Slice: ", s.current_slice, ", direction: ", s.direction, ", After local")
        -     # compare(s.greens, calculate_greens_udv_chkr(p,l,s.current_slice))
        -     # println("")
        - 
     1040     nothing
        - end
        - 
        - 
        - main(p)
        - 
        - end_time = now()
        - println("Ended: ", Dates.format(end_time, "d.u yyyy HH:MM"))
        - @printf("Duration: %.2f minutes", (end_time - start_time).value/1000./60.)
        - 
