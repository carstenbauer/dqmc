        - """
        - Checkerboard initialization: Assaad four site version for square lattice
        - """
        - function find_four_site_hopping_corners(l::Lattice)
        3   pc = Int(floor(l.sites/4))
        - 
        3   A_corners = zeros(Int, pc)
        3   idx = 1
        3   tolinidx = reshape(collect(1:l.sites),l.L,l.L)
        3   for x in 1:2:l.L
       10       for y in 1:2:l.L
       36           A_corners[idx] = tolinidx[y,x]
       36           idx += 1
        -       end
        -   end
        3   B_corners = l.neighbors[1,l.neighbors[2,A_corners]]
        3   return A_corners, B_corners
        - end
        - 
        - function build_four_site_hopping_matrix_exp(p::Parameters,l::Lattice, corners::Tuple{Array{Int64,1},Array{Int64,1}}, prefac::Float64=0.5)
        - 
        6   pc = Int(floor(l.sites/4))
        6   chkr_hop_4site = Array{SparseMatrixCSC, 3}(pc,2,2) # i, group (A, B), hopping flavor (tx, ty)
        6   chkr_hop_4site_inv = Array{SparseMatrixCSC, 3}(pc,2,2)
        - 
        -   # build explicitly based on analytic form (only without mag field)
        6   for tflv in 1:2
       12     for g in 1:2
       24       for c in 1:pc
        - 
      288         chkr_hop_4site[c,g,tflv] = speye(l.sites)
      288         chkr_hop_4site_inv[c,g,tflv] = speye(l.sites)
        - 
        -         # Tijmn where i ist bottom left and i<j<m<n.
      288         i = corners[g][c]
      288         j = l.neighbors[1,i]
      288         m = l.neighbors[2,i]
      288         n = l.neighbors[2,j]
        - 
      288         inds = sort!([corners[g][c], l.neighbors[1,i], l.neighbors[2,i], l.neighbors[2,j]])
        - 
      288         th = l.t[1,tflv]
      288         tv = l.t[2,tflv]
      288         fac = -prefac * p.delta_tau
        - 
      288         chkr_hop_4site[c,g,tflv][i,i] = chkr_hop_4site[c,g,tflv][j,j] = chkr_hop_4site[c,g,tflv][m,m] = chkr_hop_4site[c,g,tflv][n,n] = cosh(fac * -th) * cosh(fac * -tv) #
      288         chkr_hop_4site[c,g,tflv][i,n] = chkr_hop_4site[c,g,tflv][j,m] = chkr_hop_4site[c,g,tflv][m,j] = chkr_hop_4site[c,g,tflv][n,i] = sinh(fac * -th) * sinh(fac * -tv)
      288         chkr_hop_4site[c,g,tflv][i,j] = chkr_hop_4site[c,g,tflv][j,i] = chkr_hop_4site[c,g,tflv][m,n] = chkr_hop_4site[c,g,tflv][n,m] = cosh(fac * -th) * sinh(fac * -tv) #
      288         chkr_hop_4site[c,g,tflv][i,m] = chkr_hop_4site[c,g,tflv][j,n] = chkr_hop_4site[c,g,tflv][m,i] = chkr_hop_4site[c,g,tflv][n,j] = sinh(fac * -th) * cosh(fac * -tv)
        - 
      288         chkr_hop_4site_inv[c,g,tflv][i,i] = chkr_hop_4site_inv[c,g,tflv][j,j] = chkr_hop_4site_inv[c,g,tflv][m,m] = chkr_hop_4site_inv[c,g,tflv][n,n] = cosh(-fac * -th) * cosh(-fac * -tv)
      288         chkr_hop_4site_inv[c,g,tflv][i,n] = chkr_hop_4site_inv[c,g,tflv][j,m] = chkr_hop_4site_inv[c,g,tflv][m,j] = chkr_hop_4site_inv[c,g,tflv][n,i] = sinh(-fac * -th) * sinh(-fac * -tv)
      288         chkr_hop_4site_inv[c,g,tflv][i,j] = chkr_hop_4site_inv[c,g,tflv][j,i] = chkr_hop_4site_inv[c,g,tflv][m,n] = chkr_hop_4site_inv[c,g,tflv][n,m] = cosh(-fac * -th) * sinh(-fac * -tv)
      288         chkr_hop_4site_inv[c,g,tflv][i,m] = chkr_hop_4site_inv[c,g,tflv][j,n] = chkr_hop_4site_inv[c,g,tflv][m,i] = chkr_hop_4site_inv[c,g,tflv][n,j] = sinh(-fac * -th) * cosh(-fac * -tv)
        - 
        -       end
        -     end
        -   end
        - 
        6   return chkr_hop_4site, chkr_hop_4site_inv
        - end
        - 
        - function init_checkerboard_matrices(p::Parameters, l::Lattice)
        - 
        3   pc = Int(floor(l.sites/4))
        - 
        3   corners = find_four_site_hopping_corners(l)
        - 
        3   chkr_hop_4site_half, chkr_hop_4site_half_inv = build_four_site_hopping_matrix_exp(p,l, corners, 0.5)
        3   chkr_hop_4site, chkr_hop_4site_inv = build_four_site_hopping_matrix_exp(p,l, corners, 1.)
        - 
        3   eTx_A_half = foldl(*,chkr_hop_4site_half[:,1,1])
        3   eTx_B_half = foldl(*,chkr_hop_4site_half[:,2,1])
        3   eTy_A_half = foldl(*,chkr_hop_4site_half[:,1,2])
        3   eTy_B_half = foldl(*,chkr_hop_4site_half[:,2,2])
        3   eTx_A = foldl(*,chkr_hop_4site[:,1,1])
        3   eTx_B = foldl(*,chkr_hop_4site[:,2,1])
        3   eTy_A = foldl(*,chkr_hop_4site[:,1,2])
        3   eTy_B = foldl(*,chkr_hop_4site[:,2,2])
        - 
        3   eTx_A_half_inv = foldl(*,chkr_hop_4site_half_inv[:,1,1])
        3   eTx_B_half_inv = foldl(*,chkr_hop_4site_half_inv[:,2,1])
        3   eTy_A_half_inv = foldl(*,chkr_hop_4site_half_inv[:,1,2])
        3   eTy_B_half_inv = foldl(*,chkr_hop_4site_half_inv[:,2,2])
        3   eTx_A_inv = foldl(*,chkr_hop_4site_inv[:,1,1])
        3   eTx_B_inv = foldl(*,chkr_hop_4site_inv[:,2,1])
        3   eTy_A_inv = foldl(*,chkr_hop_4site_inv[:,1,2])
        3   eTy_B_inv = foldl(*,chkr_hop_4site_inv[:,2,2])
        - 
        3   eT_A_half = cat([1,2],eTx_A_half,eTy_A_half,eTx_A_half,eTy_A_half)
        3   eT_B_half = cat([1,2],eTx_B_half,eTy_B_half,eTx_B_half,eTy_B_half)
        3   eT_A_half_inv = cat([1,2],eTx_A_half_inv,eTy_A_half_inv,eTx_A_half_inv,eTy_A_half_inv)
        3   eT_B_half_inv = cat([1,2],eTx_B_half_inv,eTy_B_half_inv,eTx_B_half_inv,eTy_B_half_inv)
        3   eT_A = cat([1,2],eTx_A,eTy_A,eTx_A,eTy_A)
        3   eT_B = cat([1,2],eTx_B,eTy_B,eTx_B,eTy_B)
        3   eT_A_inv = cat([1,2],eTx_A_inv,eTy_A_inv,eTx_A_inv,eTy_A_inv)
        3   eT_B_inv = cat([1,2],eTx_B_inv,eTy_B_inv,eTx_B_inv,eTy_B_inv)
        - 
        3   l.chkr_hop_half = [eT_A_half, eT_B_half]
        3   l.chkr_hop_half_inv = [eT_A_half_inv, eT_B_half_inv]
        3   l.chkr_hop = [eT_A, eT_B]
        3   l.chkr_hop_inv = [eT_A_inv, eT_B_inv]
        - 
        3   l.chkr_mu_half = spdiagm(fill(exp(-0.5*p.delta_tau * -p.mu), p.flv * l.sites))
        3   l.chkr_mu_half_inv = spdiagm(fill(exp(0.5*p.delta_tau * -p.mu), p.flv * l.sites))
        3   l.chkr_mu = spdiagm(fill(exp(-p.delta_tau * -p.mu), p.flv * l.sites))
        3   l.chkr_mu_inv = spdiagm(fill(exp(p.delta_tau * -p.mu), p.flv * l.sites))
        - 
        3   hop_mat_exp_chkr = l.chkr_hop_half[1] * l.chkr_hop_half[2] * sqrt.(l.chkr_mu)
        3   r = effreldiff(l.hopping_matrix_exp,hop_mat_exp_chkr)
   135171   r[find(x->x==zero(x),hop_mat_exp_chkr)] = 0.
        3   println("Checkerboard - exact (abs):\t\t", maximum(absdiff(l.hopping_matrix_exp,hop_mat_exp_chkr)))
        3   println("Checkerboard - exact (eff rel):\t\t", maximum(r))
        - end
        - 
        - 
        - #### WITH ARTIFICIAL B-FIELD
        - 
        - function init_checkerboard_matrices_Bfield(p::Parameters, l::Lattice)
        - 
        0   pc = Int(floor(l.sites/4))
        - 
        0   corners = find_four_site_hopping_corners(l)
        - 
        0   chkr_hop_4site_half, chkr_hop_4site_half_inv = build_four_site_hopping_matrix_exp_Bfield(p,l, corners, 0.5)
        0   chkr_hop_4site, chkr_hop_4site_inv = build_four_site_hopping_matrix_exp_Bfield(p,l, corners, 1.)
        - 
        0   eT_half = Array{SparseMatrixCSC{HoppingType, Int}, 3}(2,2,2) # group (A, B), spin (up, down), flavor (x, y)
        0   eT_half_inv = Array{SparseMatrixCSC{HoppingType, Int}, 3}(2,2,2)
        0   eT = Array{SparseMatrixCSC{HoppingType, Int}, 3}(2,2,2)
        0   eT_inv = Array{SparseMatrixCSC{HoppingType, Int}, 3}(2,2,2)
        - 
        0   for g in 1:2
        0     for f in 1:2
        0       for s in 1:2
        0         eT_half[g,s,f] = foldl(*,chkr_hop_4site_half[:,g,s,f])
        0         eT_half_inv[g,s,f] = foldl(*,chkr_hop_4site_half_inv[:,g,s,f])
        0         eT[g,s,f] = foldl(*,chkr_hop_4site[:,g,s,f])
        0         eT_inv[g,s,f] = foldl(*,chkr_hop_4site_inv[:,g,s,f])
        -       end
        -     end
        -   end
        - 
        0   eT_A_half = cat([1,2], eT_half[1,1,1], eT_half[1,2,2], eT_half[1,2,1], eT_half[1,1,2])
        0   eT_B_half = cat([1,2], eT_half[2,1,1], eT_half[2,2,2], eT_half[2,2,1], eT_half[2,1,2])
        0   eT_A_half_inv = cat([1,2], eT_half_inv[1,1,1], eT_half_inv[1,2,2], eT_half_inv[1,2,1], eT_half_inv[1,1,2])
        0   eT_B_half_inv = cat([1,2], eT_half_inv[2,1,1], eT_half_inv[2,2,2], eT_half_inv[2,2,1], eT_half_inv[2,1,2])
        0   eT_A = cat([1,2], eT[1,1,1], eT[1,2,2], eT[1,2,1], eT[1,1,2])
        0   eT_B = cat([1,2], eT[2,1,1], eT[2,2,2], eT[2,2,1], eT[2,1,2])
        0   eT_A_inv = cat([1,2], eT_inv[1,1,1], eT_inv[1,2,2], eT_inv[1,2,1], eT_inv[1,1,2])
        0   eT_B_inv = cat([1,2], eT_inv[2,1,1], eT_inv[2,2,2], eT_inv[2,2,1], eT_inv[2,1,2])
        - 
        - 
        0   l.chkr_hop_half = [eT_A_half, eT_B_half]
        0   l.chkr_hop_half_inv = [eT_A_half_inv, eT_B_half_inv]
        0   l.chkr_hop = [eT_A, eT_B]
        0   l.chkr_hop_inv = [eT_A_inv, eT_B_inv]
        - 
        0   l.chkr_mu_half = spdiagm(fill(exp(-0.5*p.delta_tau * -p.mu), p.flv * l.sites))
        0   l.chkr_mu_half_inv = spdiagm(fill(exp(0.5*p.delta_tau * -p.mu), p.flv * l.sites))
        0   l.chkr_mu = spdiagm(fill(exp(-p.delta_tau * -p.mu), p.flv * l.sites))
        0   l.chkr_mu_inv = spdiagm(fill(exp(p.delta_tau * -p.mu), p.flv * l.sites))
        - 
        0   hop_mat_exp_chkr = l.chkr_hop_half[1] * l.chkr_hop_half[2] * sqrt.(l.chkr_mu)
        0   r = effreldiff(l.hopping_matrix_exp,hop_mat_exp_chkr)
        0   r[find(x->x==zero(x),hop_mat_exp_chkr)] = 0.
        0   println("Checkerboard (Bfield) - exact (abs):\t\t", maximum(absdiff(l.hopping_matrix_exp,hop_mat_exp_chkr)))
        0   println("Checkerboard (Bfield) - exact (eff rel):\t\t", maximum(r))
        - end
        - 
        - 
        - 
        - function build_four_site_hopping_matrix_Bfield(p::Parameters,l::Lattice, corner::Int,f::Int, B::Float64, sql::Matrix{Int})
        0   sites_clockwise = [corner, l.neighbors[1,corner], l.neighbors[1,l.neighbors[2,corner]], l.neighbors[2,corner]]
        0   shift_sites_clockwise = circshift(sites_clockwise,-1)
        - 
        0   h = l.t[1,f]
        0   v = l.t[2,f]
        - 
        0   hop = -1 * repeat(HoppingType[v, h, v, h], outer=2)
        - 
        0   @inbounds for k in 1:4
        0     i = sites_clockwise[k]
        0     j = shift_sites_clockwise[k]
        - 
        0     hop[k] *= peirls(i,j,B,sql)
        0     hop[k+4] *= peirls(j,i,B,sql)
        -   end
        - 
        0   return sparse([sites_clockwise; shift_sites_clockwise],[shift_sites_clockwise; sites_clockwise],hop,l.sites,l.sites)
        - end
        - 
        - # helper to cutoff numerical zeros
        - rem_eff_zeros!(X::Array{Float64}) = map!(e->abs.(e)<1e-15?zero(e):e,X)
        - rem_eff_zeros!(X::Array{Complex128}) = map!(e->abs.(e)<1e-15?zero(e):e,X)
        - 
        - function build_four_site_hopping_matrix_exp_Bfield(p::Parameters,l::Lattice, corners::Tuple{Array{Int64,1},Array{Int64,1}}, prefac::Float64=0.5)
        - 
        0   B = zeros(2,2) # rowidx = spin up,down, colidx = flavor
        0   if p.Bfield
        0     B[1,1] = B[2,2] = 1./l.sites
        0     B[1,2] = B[2,1] = - 1./l.sites
        -   end
        - 
        -   # for linidx to cartesianidx   
        0   sql = reshape(collect(1:l.sites), (l.L,l.L))
        - 
        0   pc = Int(floor(l.sites/4))
        - 
        0   chkr_hop_4site = Array{SparseMatrixCSC{HoppingType, Int}, 4}(pc,2,2,2) # i, group (A, B), spin (up, down), flavor (x, y)
        0   chkr_hop_4site_inv = Array{SparseMatrixCSC{HoppingType, Int}, 4}(pc,2,2,2)
        - 
        -   # build numerically (due to mag field)
        0   for f in 1:2
        0     for s in 1:2
        0       for g in 1:2
        0         for c in 1:pc
        - 
        0           fac = -prefac * p.delta_tau
        -           
        0           chkr_hop_4site[c,g,s,f] = sparse(rem_eff_zeros!(expm(fac * full(build_four_site_hopping_matrix_Bfield(p,l,corners[g][c],f,B[s,f],sql)))))
        0           chkr_hop_4site_inv[c,g,s,f] = sparse(rem_eff_zeros!(expm(-fac * full(build_four_site_hopping_matrix_Bfield(p,l,corners[g][c],f,B[s,f],sql)))))
        - 
        -         end
        -       end
        -     end
        -   end
        - 
        0   return chkr_hop_4site, chkr_hop_4site_inv
        - end
        - 
        - 
        - 
        - 
        - 
        - """
        - Slice matrix
        - """
        - function slice_matrix(p::Parameters, l::Lattice, slice::Int, power::Float64=1.)
     1040   res = eye(Complex128, p.flv*l.sites)
      520   if power > 0
      520     multiply_slice_matrix_left!(p, l, slice, res)
        -   else
        0     multiply_slice_matrix_inv_left!(p, l, slice, res)
        -   end
      520   return res
        - end
        - 
        - function multiply_slice_matrix_left!{T<:Number}(p::Parameters, l::Lattice, slice::Int, M::Matrix{T})
        - 
     1708   M[:] = interaction_matrix_exp(p, l, slice) * M
     1708   M[:] = l.chkr_mu * M
        - 
     1708   M[:] = l.chkr_hop_half[2] * M
     1708   M[:] = l.chkr_hop[1] * M
     1708   M[:] = l.chkr_hop_half[2] * M
        - end
        - 
        - function multiply_slice_matrix_right!{T<:Number}(p::Parameters, l::Lattice, slice::Int, M::Matrix{T})
        - 
      524   M[:] = M * l.chkr_hop_half[2]
      524   M[:] = M * l.chkr_hop[1]
      524   M[:] = M * l.chkr_hop_half[2]
        - 
      524   M[:] = M * l.chkr_mu
      524   M[:] = M * interaction_matrix_exp(p, l, slice)
        - end
        - 
        - function multiply_slice_matrix_inv_left!{T<:Number}(p::Parameters, l::Lattice, slice::Int, M::Matrix{T})
        - 
      524   M[:] = l.chkr_hop_half_inv[2] * M
      524   M[:] = l.chkr_hop_inv[1] * M
      524   M[:] = l.chkr_hop_half_inv[2] * M
        - 
      524   M[:] = l.chkr_mu_inv * M
      524   M[:] = interaction_matrix_exp(p, l, slice, -1.) * M
        - end
        - 
        - function multiply_slice_matrix_inv_right!{T<:Number}(p::Parameters, l::Lattice, slice::Int, M::Matrix{T})
        - 
      508   M[:] = M * interaction_matrix_exp(p, l, slice, -1.)
      508   M[:] = M * l.chkr_mu_inv
        - 
      508   M[:] = M * l.chkr_hop_half_inv[2]
      508   M[:] = M * l.chkr_hop_inv[1]
      508   M[:] = M * l.chkr_hop_half_inv[2]
        - end
        - 
        - function multiply_slice_matrix_left{T<:Number}(p::Parameters, l::Lattice, slice::Int, M::Matrix{T})
        -   X = copy(M)
        -   multiply_slice_matrix_left!(p, l, slice, X)
        -   return X
        - end
        - 
        - function multiply_slice_matrix_right{T<:Number}(p::Parameters, l::Lattice, slice::Int, M::Matrix{T})
        -   X = copy(M)
        -   multiply_slice_matrix_right!(p, l, slice, X)
        -   return X
        - end
        - 
        - function multiply_slice_matrix_inv_left{T<:Number}(p::Parameters, l::Lattice, slice::Int, M::Matrix{T})
        -   X = copy(M)
        -   multiply_slice_matrix_inv_left!(p, l, slice, X)
        -   return X
        - end
        - 
        - function multiply_slice_matrix_inv_right{T<:Number}(p::Parameters, l::Lattice, slice::Int, M::Matrix{T})
        -   X = copy(M)
        -   multiply_slice_matrix_inv_right!(p, l, slice, X)
        -   return X
        - end
